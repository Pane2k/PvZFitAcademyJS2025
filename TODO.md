
---

# TODO.md: Пошаговый план разработки "PvZ Fusion"

**Цель:** Создать полный, пошаговый план от инициализации проекта до финальной полировки. Каждый пункт представляет собой небольшой, законченный шаг.

---

## **Этап 1: Фундамент Движка и Рендеринг (Engine Core & Rendering)**
*Цель: Создать минимально работающее приложение, которое может отрисовать один объект на экране. Вся базовая архитектура закладывается здесь.*

-   [+] **1.1. Настройка Окружения**
    -   [+] Создать структуру папок: `/`, `/assets/images`, `/data`, `/src`, `/src/core`, `/src/ecs`, `/src/ecs/components`, `/src/ecs/systems`, `/src/game`, `/src/game/states`, `/src/ui`.
    -   [+] Создать `index.html` с тегом `<canvas id="game-canvas">`.
    -   [+] Создать базовый `style.css` для сброса стилей и растягивания canvas на весь экран (`width: 100%; height: 100%`).
    -   [+] Создать точку входа `src/main.js`.

-   [+] **1.2. Ядро Игрового Цикла (`/src/core`)**
    -   [+] **`GameLoop.js`**:
        -   [+] Создать класс `GameLoop` с методами `start()` и `stop()`.
        -   [+] Реализовать основной метод `loop(timestamp)`, использующий `requestAnimationFrame`.
        -   [+] Внутри `loop` рассчитать `deltaTime` (время с прошлого кадра) для независимой от FPS логики.
        -   [+] Вызывать колбэки `update(deltaTime)` и `render()` на каждом кадре.

-   [+] **1.3. Система Отрисовки (`/src/core`)**
    -   [+] **`Renderer.js`**:
        -   [+] Создать класс, принимающий в конструкторе `canvas` и `context`.
        -   [+] Реализовать метод `clear()` для очистки холста.
        -   [+] Реализовать метод `drawImage(image, x, y, width, height)`.
        -   [+] Реализовать метод `resize(width, height)` для обработки изменения размера окна и масштабирования. Добавить прослушиватель `window.onresize`.

-   [+] **1.4. Базовая Реализация ECS (`/src/ecs`)**
    -   [+] **`World.js`**:
        -   [+] Создать класс `World`.
        -   [+] Реализовать `createEntity()`: возвращает уникальный ID.
        -   [+] Реализовать `addComponent(entityId, component)`.
        -   [+] Реализовать `addSystem(system)` и `removeSystem(system)`.
        -   [+] Реализовать `getEntitiesWithComponents(...componentClasses)`: возвращает массив сущностей, у которых есть все перечисленные компоненты.
        -   [+] Реализовать `update(deltaTime)`, который итерируется по всем системам и вызывает их метод `update`.
    -   [+] **Компоненты (`/src/ecs/components`)**:
        -   [+] `PositionComponent.js` (содержит x, y, width, height).
        -   [+] `SpriteComponent.js` (содержит объект `Image`, возможно, путь к файлу).
        -   [+] `RenderableComponent.js` (пустой компонент-тег для удобства запросов).
    -   [+] **Системы (`/src/ecs/systems`)**:
        -   [+] **`RenderSystem.js`**:
            -   [+] В методе `update()` запрашивает у `World` все сущности с `PositionComponent`, `SpriteComponent`, `RenderableComponent`.
            -   [+] Итерируется по ним и вызывает `renderer.drawImage()` для каждой.

-   [ ] **1.5. Сборка и Первый Запуск**
    -   [ ] **`AssetLoader.js` (`/src/core`)**:
        -   [ ] Создать класс `AssetLoader`.
        -   [ ] Реализовать метод `loadImage(path)` который возвращает `Promise`.
    -   [ ] **`Game.js` (`/src/game`)**:
        -   [ ] Создать главный класс `Game`.
        -   [ ] В конструкторе инициализировать `Renderer`, `World`, `GameLoop`.
        -   [ ] Добавить `RenderSystem` в `World`.
    -   [ ] **В `main.js`**:
        -   [ ] Создать экземпляр `Game`.
        -   [ ] Использовать `AssetLoader` чтобы загрузить одно тестовое изображение.
        -   [ ] После загрузки: создать в `World` одну сущность, добавить ей `Position` и `Sprite` компоненты.
        -   [ ] Запустить `GameLoop`.
    -   [ ] **Цель этапа:** Увидеть на экране один статичный спрайт, отрисованный через ECS.

---

## **Этап 2: Интерактивность и Управление Состояниями**
*Цель: Заставить мир реагировать на действия пользователя и внедрить базовую игровую структуру.*

-   [ ] **2.1. Обработка Ввода (`/src/core`)**
    -   [ ] **`EventBus.js`**:
        -   [ ] Реализовать простой Pub/Sub с методами `subscribe(eventName, callback)` и `publish(eventName, data)`.
    -   [ ] **`InputHandler.js`**:
        -   [ ] Настроить прослушиватели событий `mousedown` и `touchstart`.
        -   [ ] Нормализовать координаты клика/касания относительно `canvas`.
        -   [ ] Опубликовать событие `input:click` в `EventBus` с координатами.

-   [ ] **2.2. Управление Состояниями (`/src/game`)**
    -   [ ] **`StateManager.js`**:
        -   [ ] Создать менеджер с методами `changeState(newState)` и `update(deltaTime)`.
    -   [ ] **`states/BaseState.js`**:
        -   [ ] Создать базовый класс/интерфейс для всех состояний (`enter()`, `exit()`, `update(deltaTime)`).
    -   [ ] **`states/GameplayState.js`**:
        -   [ ] Создать состояние игрового процесса. В его методе `enter` должны создаваться и добавляться в `World` все игровые системы. В `exit` - удаляться.
        -   [ ] Перенести логику создания систем из `Game.js` в `GameplayState.js`.

-   [ ] **2.3. Data-Driven Design (Основа)**
    -   [ ] Создать `data/entities.json`. Описать в нем "Горохострел" с его компонентами.
    -   [ ] В `AssetLoader.js` добавить метод `loadJSON(path)`.
    -   [ ] **`Factory.js` (`/src/game`)**:
        -   [ ] Создать фабрику, которая в конструкторе принимает `World` и загруженные данные из `entities.json`.
        -   [ ] Реализовать метод `create(entityName, position)`, который создает сущность и добавляет ей все компоненты из JSON-префаба.

-   [ ] **2.4. Первая Интерактивность**
    -   [ ] **`PlayerInputSystem.js` (`/src/ecs/systems`)**:
        -   [ ] Создать систему, которая подписывается на `input:click` из `EventBus`.
        -   [ ] При получении события, использует `Factory` для создания "Горохострела" в точке клика.
    -   [ ] **Цель этапа:** При клике на холст на экране появляется спрайт горохострела.

---

## **Этап 3: Реализация Основного Геймплея (Core Gameplay Loop)**
*Цель: Внедрить все ключевые механики, описанные в GDD: ресурсы, зомби, атака, защита.*

-   [ ] **3.1. Ресурсы ("Солнце")**
    -   [ ] Добавить префаб "Солнца" в `entities.json`.
    -   [ ] `SunSpawningSystem.js`: система, которая с определенным интервалом создает сущность "падающего солнца" в случайной точке вверху экрана.
    -   [ ] `MovementSystem.js`: простая система, которая обновляет `PositionComponent` на основе `VelocityComponent`. Добавить "солнцу" вертикальную скорость.
    -   [ ] `PlayerInputSystem.js`: расширить логику, чтобы при клике проверять, не попал ли игрок на сущность с компонентом `Collectible`. Если да - увеличить счетчик ресурсов и удалить сущность "солнца".

-   [ ] **3.2. Посадка Растений (UI)**
    -   [ ] **`HUD.js` (`/src/ui`)**:
        -   [ ] Создать класс для отрисовки UI.
        -   [ ] Реализовать отрисовку счетчика "солнца".
        -   [ ] Реализовать отрисовку карточек растений (пока статично).
    -   [ ] Расширить `PlayerInputSystem.js`: теперь клик сначала обрабатывается UI. Если клик на карточке - "выбираем" это растение. Если клик по полю с "выбранным" растением - сажаем его, тратя ресурсы.

-   [ ] **3.3. Зомби и Волны**
    -   [ ] Добавить префаб "Обычного зомби" в `entities.json`.
    -   [ ] Создать `data/levels.json` и описать первую простую волну.
    -   [ ] **`WaveSystem.js`**:
        -   [ ] Система, которая загружает `levels.json`.
        -   [ ] Реализовать логику запуска волн по таймеру.
        -   [ ] В момент запуска волны, использует `Factory` для создания зомби за пределами правой части экрана.
    -   [ ] Расширить `MovementSystem.js` для движения зомби влево.

-   [ ] **3.4. Боевая Система**
    -   [ ] Добавить префаб "Горошины" (снаряда) в `entities.json`.
    -   [ ] `ShootingSystem.js`: система, которая находит сущности с `ShootsProjectilesComponent` (Горохострел), и с определенным интервалом создает сущность "Горошины" с помощью `Factory`.
    -   [ ] `CollisionSystem.js`: система, которая проверяет пересечение bounding-box'ов (прямоугольников) сущностей (горошина-зомби, зомби-растение). При столкновении публикует событие в `EventBus`.
    -   [ ] `HealthComponent.js`: добавить этот компонент всем "живым" сущностям.
    -   [ ] `DamageSystem.js`: система, которая слушает события столкновений. При столкновении горошины и зомби, уменьшает `HealthComponent` у зомби.
    -   [ ] `CleanupSystem.js`: система, которая в конце кадра удаляет из `World` все сущности, у которых здоровье <= 0.
    -   [ ] **Цель этапа:** На поле можно сажать горохострелы, они стреляют в идущих зомби, зомби получают урон и исчезают.

---

## **Этап 4: Ключевая Механика Слияния (Fusion)**
*Цель: Реализовать уникальную фичу игры - слияние растений.*

-   [ ] **4.1. Ввод Drag-and-Drop**
    -   [ ] Расширить `InputHandler.js` для отслеживания `mousemove`/`touchmove` и `mouseup`/`touchend`.
    -   [ ] Публиковать события: `input:dragstart` (на mousedown), `input:dragmove`, `input:dragend`.

-   [ ] **4.2. Логика Слияния**
    -   [ ] Добавить префаб гибрида "Солнечный Стрелок" в `entities.json`.
    -   [ ] `FusionSystem.js`:
        -   [ ] Подписаться на события `input:drag...`.
        -   [ ] На `dragstart` определять, какое растение "схватили".
        -   [ ] На `dragend` определять, над каким растением "отпустили".
        -   [ ] Создать "книгу рецептов" (простой объект JS), где `Горохострел + Подсолнух = СолнечныйСтрелок`.
        -   [ ] Если рецепт совпадает, удалить обе исходные сущности и создать на их месте гибрид с помощью `Factory`.
    -   [ ] **Цель этапа:** Можно перетащить подсолнух на горохострел, и они превратятся в один новый юнит, который и стреляет, и производит солнце.

---

## **Этап 5: Полировка и Завершение (Polish & Completion)**
*Цель: Довести проект до состояния готового продукта, добавив звук, анимацию, полное UI и выполнив все требования на высшую оценку.*

-   [ ] **5.1. Расширенный UI и UX**
    -   [ ] `HUD.js`: Реализовать индикатор прогресса волн.
    -   [ ] `HUD.js`: Реализовать визуализацию перезарядки карточек.
    -   [ ] Добавить иконку "Лопаты" и реализовать логику удаления растений.

-   [ ] **5.2. Мультимедиа**
    -   [ ] `SoundManager.js`: Создать менеджер на **Web Audio API** для проигрывания звуков.
    -   [ ] `AssetLoader.js`: Добавить метод `loadAudio`. Загрузить звуки выстрелов, попаданий, сбора солнца.
    -   [ ] Интегрировать вызовы `soundManager.play()` в соответствующие системы (`ShootingSystem`, `PlayerInputSystem` и т.д.).
    -   [ ] **Анимация**:
        -   [ ] Обновить `SpriteComponent`, добавив в него данные для анимации (количество кадров, скорость).
        -   [ ] Обновить `RenderSystem`, чтобы она отрисовывала нужный кадр из спрайт-листа в каждый момент времени.
    -   [ ] **Вибрация**:
        -   [ ] В ключевые моменты (срабатывание газонокосилки, потеря уровня) вызывать `navigator.vibrate()` на мобильных устройствах.

-   [ ] **5.3. Сохранение Прогресса и Завершение Игры**
    -   [ ] Реализовать логику победы (все волны отбиты) и поражения (зомби дошел до дома).
    -   [ ] Создать `MainMenuState.js`, `WinState.js`, `LoseState.js`.
    -   [ ] `ProgressManager.js`: Создать менеджер, использующий `localStorage` для сохранения информации о пройденных уровнях.

-   [ ] **5.4. Финальное Тестирование**
    -   [ ] Проверить адаптивность на разных размерах экрана (десктоп, мобильный в портретной и ландшафтной ориентации).
    -   [ ] Проверить кросс-браузерность (Chrome, Firefox, Safari).
    -   [ ] Убедиться в полном отсутствии ошибок в консоли разработчика.
    -   [ ] Провести плейтест, сбалансировать стоимость растений и сложность волн в JSON файлах.